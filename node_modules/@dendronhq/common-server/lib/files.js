"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeMDExtension = exports.resolvePath = exports.resolveTilde = exports.getAllFiles = exports.globMatch = exports.deleteFile = exports.writeYAML = exports.readYAML = exports.readMD = exports.findInParent = exports.cleanFileName = exports.cleanName = void 0;
const fs_1 = __importDefault(require("fs"));
const gray_matter_1 = __importDefault(require("gray-matter"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const lodash_1 = __importDefault(require("lodash"));
const minimatch_1 = __importDefault(require("minimatch"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
/**
 * Make name safe for dendron
 * @param name
 * @param opts
 */
function cleanName(name) {
    name = name
        .replace(new RegExp(lodash_1.default.escapeRegExp(path_1.default.sep), "g"), ".")
        .toLocaleLowerCase();
    name = name.replace(/ /g, "-");
    return name;
}
exports.cleanName = cleanName;
/**
 *
 * Normalize file name
 * - strip off extension
 * - replace [.\s] with -
 * @param name
 * @param opts
 *   - isDir: dealing with directory
 */
function cleanFileName(name, opts) {
    const cleanOpts = lodash_1.default.defaults(opts, { isDir: false });
    if (!cleanOpts.isDir) {
        const { name: fname, dir } = path_1.default.parse(name);
        // strip off extension
        name = path_1.default.join(dir, fname);
    }
    name = name.replace(/\./g, "-");
    // replace all names already in file name
    //name = name.replace(/\./g, "-");
    name = cleanName(name);
    // if file, only get name (no extension)
    return name;
}
exports.cleanFileName = cleanFileName;
function findInParent(base, fname) {
    let acc = 10;
    const lvls = [];
    while (acc > 0) {
        const tryPath = path_1.default.join(base, ...lvls, fname);
        if (fs_1.default.existsSync(tryPath)) {
            return path_1.default.dirname(tryPath);
        }
        acc -= 1;
        lvls.push("..");
    }
    return;
}
exports.findInParent = findInParent;
function readMD(fpath) {
    return gray_matter_1.default.read(fpath, {});
}
exports.readMD = readMD;
function readYAML(fpath) {
    return js_yaml_1.default.safeLoad(fs_1.default.readFileSync(fpath, { encoding: "utf8" }), {
        schema: js_yaml_1.default.JSON_SCHEMA,
    });
}
exports.readYAML = readYAML;
function writeYAML(fpath, data) {
    const out = js_yaml_1.default.safeDump(data, { indent: 4, schema: js_yaml_1.default.JSON_SCHEMA });
    return fs_1.default.writeFileSync(fpath, out);
}
exports.writeYAML = writeYAML;
function deleteFile(fpath) {
    return fs_1.default.unlinkSync(fpath);
}
exports.deleteFile = deleteFile;
function globMatch(patterns, fname) {
    if (lodash_1.default.isString(patterns)) {
        return minimatch_1.default(fname, patterns);
    }
    return lodash_1.default.some(patterns, (pattern) => minimatch_1.default(fname, pattern));
}
exports.globMatch = globMatch;
function getAllFiles(opts) {
    const { root, withFileTypes } = lodash_1.default.defaults(opts, {
        exclude: [".git", "Icon\r", ".*"],
        withFileTypes: false,
    });
    const allFiles = fs_1.default.readdirSync(root, { withFileTypes: true });
    return lodash_1.default.reject(allFiles.map((dirent) => {
        const { name: fname } = dirent;
        // match exclusions
        if (lodash_1.default.some([dirent.isDirectory(), globMatch(opts.exclude || [], fname)])) {
            return null;
        }
        // match inclusion
        if (opts.include && !globMatch(opts.include, fname)) {
            return null;
        }
        if (withFileTypes) {
            return dirent;
        }
        else {
            return dirent.name;
        }
    }), lodash_1.default.isNull);
}
exports.getAllFiles = getAllFiles;
/**
 * Convert a node to a MD File. Any custom attributes will be
 * added to the end
 *
 * @param node: node to convert
 * @param opts
 *   - root: root folder where files should be written to
 */
function resolveTilde(filePath) {
    if (!filePath || typeof filePath !== "string") {
        return "";
    }
    // '~/folder/path' or '~'
    if (filePath[0] === "~" && (filePath[1] === "/" || filePath.length === 1)) {
        return filePath.replace("~", os_1.default.homedir());
    }
    return filePath;
}
exports.resolveTilde = resolveTilde;
/**
 * Resolve file path and resolve relative paths relative to `root`
 * @param filePath
 * @param root
 */
function resolvePath(filePath, root) {
    const platform = os_1.default.platform();
    const isWin = platform === "win32";
    if (filePath[0] === "~") {
        return resolveTilde(filePath);
    }
    else if (path_1.default.isAbsolute(filePath) ||
        (isWin && filePath.startsWith("\\"))) {
        return filePath;
    }
    else {
        if (!root) {
            throw Error("can't use rel path without a workspace root set");
        }
        return path_1.default.join(root, filePath);
    }
}
exports.resolvePath = resolvePath;
// @deprecate, NoteUtils.normalizeFname
function removeMDExtension(nodePath) {
    const idx = nodePath.lastIndexOf(".md");
    if (idx > 0) {
        nodePath = nodePath.slice(0, idx);
    }
    return nodePath;
}
exports.removeMDExtension = removeMDExtension;
//# sourceMappingURL=files.js.map