"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DevCLICommand = exports.DevCommands = void 0;
const common_all_1 = require("@dendronhq/common-all");
const fs_extra_1 = __importDefault(require("fs-extra"));
const common_server_1 = require("@dendronhq/common-server");
const path_1 = __importDefault(require("path"));
const __1 = require("..");
const build_1 = require("../utils/build");
const base_1 = require("./base");
const engine_server_1 = require("@dendronhq/engine-server");
const lodash_1 = __importDefault(require("lodash"));
var DevCommands;
(function (DevCommands) {
    DevCommands["GENERATE_JSON_SCHEMA_FROM_CONFIG"] = "generate_json_schema_from_config";
    DevCommands["BUILD"] = "build";
    DevCommands["BUMP_VERSION"] = "bump_version";
    DevCommands["PUBLISH"] = "publish";
    DevCommands["SYNC_ASSETS"] = "sync_assets";
    DevCommands["PREP_PLUGIN"] = "prep_plugin";
    DevCommands["PACKAGE_PLUGIN"] = "package_plugin";
    DevCommands["INSTALL_PLUGIN"] = "install_plugin";
    DevCommands["ENABLE_TELEMETRY"] = "enable_telemetry";
    DevCommands["DISABLE_TELEMETRY"] = "disable_telemetry";
    DevCommands["SHOW_TELEMETRY"] = "show_telemetry";
    DevCommands["SHOW_MIGRATIONS"] = "show_migrations";
    DevCommands["RUN_MIGRATION"] = "run_migration";
})(DevCommands = exports.DevCommands || (exports.DevCommands = {}));
/**
 * To use when working on dendron
 */
class DevCLICommand extends base_1.CLICommand {
    constructor() {
        super({
            name: "dev <cmd>",
            desc: "commands related to development of Dendron",
        });
        this.wsRootOptional = true;
        this.skipValidation = true;
    }
    setEndpoint(publishEndpoint) {
        this.print(`setting endpoint to ${publishEndpoint}...`);
        if (publishEndpoint === build_1.PublishEndpoint.LOCAL) {
            build_1.BuildUtils.prepPublishLocal();
        }
        else {
            build_1.BuildUtils.prepPublishRemote();
        }
    }
    buildArgs(args) {
        super.buildArgs(args);
        args.positional("cmd", {
            describe: "a command to run",
            choices: Object.values(DevCommands),
            type: "string",
        });
        args.option("upgradeType", {
            describe: "how to do upgrade",
            choices: Object.values(build_1.SemverVersion),
        });
        args.option("publishEndpoint", {
            describe: "where to publish",
            choices: Object.values(build_1.PublishEndpoint),
        });
        args.option("extensionTarget", {
            describe: "extension name to publish in the marketplace",
            choices: Object.values(build_1.ExtensionTarget),
        });
        args.option("fast", {
            describe: "skip some checks",
        });
        args.option("migrationVersion", {
            describe: "migration version to run",
            choices: engine_server_1.ALL_MIGRATIONS.map((m) => m.version),
        });
        args.option("wsRoot", {
            describe: "root directory of the Dendron workspace",
        });
    }
    async enrichArgs(args) {
        this.addArgsToPayload({ cmd: args.cmd });
        return { data: { ...args } };
    }
    async generateJSONSchemaFromConfig() {
        const repoRoot = process.cwd();
        const pkgRoot = path_1.default.join(repoRoot, "packages", "engine-server");
        const nextOutputPath = path_1.default.join(repoRoot, "packages", "dendron-next-server", "data", "dendron-yml.validator.json");
        const commonOutputPath = path_1.default.join(repoRoot, "packages", "common-all", "data", "dendron-yml.validator.json");
        const pluginOutputPath = path_1.default.join(repoRoot, "packages", "plugin-core", "dist", "dendron-yml.validator.json");
        const configType = "StrictConfigV4";
        // NOTE: this is removed by webpack when building plugin which is why we're loading this dynamically
        // eslint-disable-next-line global-require
        const tsj = require("ts-json-schema-generator");
        const schema = tsj
            .createGenerator({
            path: path_1.default.join(pkgRoot, "src", "config.ts"),
            tsconfig: path_1.default.join(pkgRoot, "tsconfig.build.json"),
            type: configType,
            skipTypeCheck: true,
        })
            .createSchema(configType);
        const schemaString = JSON.stringify(schema, null, 2);
        fs_extra_1.default.ensureDirSync(path_1.default.dirname(pluginOutputPath));
        await Promise.all([
            fs_extra_1.default.writeFile(nextOutputPath, schemaString),
            fs_extra_1.default.writeFile(commonOutputPath, schemaString),
            fs_extra_1.default.writeFile(pluginOutputPath, schemaString),
        ]);
        return;
    }
    async execute(opts) {
        const { cmd } = opts;
        const ctx = "execute";
        this.L.info({ ctx });
        try {
            switch (cmd) {
                case DevCommands.GENERATE_JSON_SCHEMA_FROM_CONFIG: {
                    await this.generateJSONSchemaFromConfig();
                    return { error: null };
                }
                case DevCommands.BUILD: {
                    if (!this.validateBuildArgs(opts)) {
                        return {
                            error: new common_all_1.DendronError({
                                message: "missing options for build command",
                            }),
                        };
                    }
                    await this.build(opts);
                    return { error: null };
                }
                case DevCommands.BUMP_VERSION: {
                    if (!this.validateBumpVersionArgs(opts)) {
                        return {
                            error: new common_all_1.DendronError({
                                message: "missing options for build command",
                            }),
                        };
                    }
                    await this.bumpVersion(opts);
                    return { error: null };
                }
                case DevCommands.SYNC_ASSETS: {
                    await this.syncAssets(opts);
                    return { error: null };
                }
                case DevCommands.PUBLISH: {
                    if (!opts.publishEndpoint) {
                        return {
                            error: new common_all_1.DendronError({
                                message: "missing options for cmd",
                            }),
                        };
                    }
                    try {
                        this.setEndpoint(opts.publishEndpoint);
                        await build_1.LernaUtils.publishVersion(opts.publishEndpoint);
                    }
                    finally {
                        if (opts.publishEndpoint === build_1.PublishEndpoint.LOCAL) {
                            build_1.BuildUtils.setRegRemote();
                        }
                    }
                    return { error: null };
                }
                case DevCommands.PREP_PLUGIN: {
                    if (!this.validatePrepPluginArgs(opts)) {
                        return {
                            error: new common_all_1.DendronError({
                                message: "missing options for prep_plugin command",
                            }),
                        };
                    }
                    await build_1.BuildUtils.prepPluginPkg(opts.extensionTarget);
                    return { error: null };
                }
                case DevCommands.PACKAGE_PLUGIN: {
                    if (!opts.fast) {
                        this.print("install deps...");
                        build_1.BuildUtils.installPluginDependencies();
                    }
                    this.print("compiling plugin...");
                    await build_1.BuildUtils.compilePlugin(opts);
                    this.print("package deps...");
                    await build_1.BuildUtils.packagePluginDependencies(opts);
                    return { error: null };
                }
                case DevCommands.INSTALL_PLUGIN: {
                    const currentVersion = build_1.BuildUtils.getCurrentVersion();
                    await build_1.BuildUtils.installPluginLocally(currentVersion);
                    return { error: null };
                }
                case DevCommands.ENABLE_TELEMETRY: {
                    this.enableTelemetry();
                    return { error: null };
                }
                case DevCommands.DISABLE_TELEMETRY: {
                    this.disableTelemetry();
                    return { error: null };
                }
                case DevCommands.SHOW_TELEMETRY: {
                    __1.CLIAnalyticsUtils.showTelemetryMessage();
                    return { error: null };
                }
                case DevCommands.SHOW_MIGRATIONS: {
                    this.showMigrations();
                    return { error: null };
                }
                case DevCommands.RUN_MIGRATION: {
                    if (!this.validateRunMigrationArgs(opts)) {
                        return {
                            error: new common_all_1.DendronError({
                                message: "missing option(s) for run_migration command",
                            }),
                        };
                    }
                    this.runMigration(opts);
                    return { error: null };
                }
                default:
                    return (0, common_all_1.assertUnreachable)(cmd);
            }
        }
        catch (err) {
            this.L.error(err);
            if (err instanceof common_all_1.DendronError) {
                this.print(["status:", err.status, err.message].join(" "));
            }
            else {
                this.print("unknown error " + (0, common_all_1.error2PlainObject)(err));
            }
            return { error: err };
        }
    }
    async bumpVersion(opts) {
        this.print("bump version...");
        build_1.LernaUtils.bumpVersion(opts.upgradeType);
    }
    async build(opts) {
        const ctx = "build";
        // get package version
        const currentVersion = build_1.BuildUtils.getCurrentVersion();
        const nextVersion = build_1.BuildUtils.genNextVersion({
            currentVersion,
            upgradeType: opts.upgradeType,
        });
        const shouldPublishLocal = opts.publishEndpoint === build_1.PublishEndpoint.LOCAL;
        this.L.info({ ctx, currentVersion, nextVersion });
        this.print(`prep publish ${opts.publishEndpoint}...`);
        if (shouldPublishLocal) {
            this.print("setting endpoint to local");
            await build_1.BuildUtils.prepPublishLocal();
        }
        else {
            this.print("setting endpoint to remote");
            await build_1.BuildUtils.prepPublishRemote();
        }
        if (!opts.fast) {
            this.print("run type-check...");
            build_1.BuildUtils.runTypeCheck();
        }
        else {
            this.print("skipping type-check...");
        }
        this.bumpVersion(opts);
        this.print("publish version...");
        await build_1.LernaUtils.publishVersion(opts.publishEndpoint);
        this.print("sync assets...");
        await this.syncAssets(opts);
        this.print("prep repo...");
        await build_1.BuildUtils.prepPluginPkg();
        this.print("install deps...");
        build_1.BuildUtils.installPluginDependencies();
        this.print("compiling plugin...");
        await build_1.BuildUtils.compilePlugin(opts);
        if (opts.extensionTarget === build_1.ExtensionTarget.NIGHTLY) {
            this.print("modifying plugin manifest for nightly target...");
            await build_1.BuildUtils.prepPluginPkg(build_1.ExtensionTarget.NIGHTLY);
        }
        this.print("package deps...");
        await build_1.BuildUtils.packagePluginDependencies(opts);
        this.print("setRegRemote...");
        build_1.BuildUtils.setRegRemote();
        if (!opts.fast) {
            this.print("restore package.json...");
            build_1.BuildUtils.restorePluginPkgJson();
        }
        else {
            this.print("skip restore package.json...");
        }
        this.L.info("done");
    }
    /**
     * Takes assets from different monorepo packages and copies them over to the plugin
     * @param param0
     * @returns
     */
    async syncAssets({ fast }) {
        if (!fast) {
            this.print("build next server for prod...");
            build_1.BuildUtils.buildNextServer();
            this.print("build plugin views for prod...");
            build_1.BuildUtils.buildPluginViews();
        }
        this.print("sync static...");
        const { staticPath } = await build_1.BuildUtils.syncStaticAssets();
        await build_1.BuildUtils.syncStaticAssetsToNextjsTemplate();
        return { staticPath };
    }
    validateBuildArgs(opts) {
        if (!opts.upgradeType || !opts.publishEndpoint) {
            return false;
        }
        return true;
    }
    validateBumpVersionArgs(opts) {
        if (!opts.upgradeType) {
            return false;
        }
        return true;
    }
    validatePrepPluginArgs(opts) {
        if (opts.extensionTarget) {
            return Object.values(build_1.ExtensionTarget).includes(opts.extensionTarget);
        }
        return true;
    }
    validateRunMigrationArgs(opts) {
        if (!opts.wsRoot) {
            return false;
        }
        if (opts.migrationVersion) {
            return engine_server_1.ALL_MIGRATIONS.map((m) => m.version).includes(opts.migrationVersion);
        }
        return true;
    }
    enableTelemetry() {
        const reason = common_server_1.TelemetryStatus.ENABLED_BY_CLI_COMMAND;
        common_server_1.SegmentClient.enable(reason);
        __1.CLIAnalyticsUtils.track(common_all_1.CLIEvents.CLITelemetryEnabled, { reason });
        const message = [
            "Telemetry is enabled.",
            "Thank you for helping us improve Dendron ðŸŒ±",
        ].join("\n");
        this.print(message);
    }
    disableTelemetry() {
        const reason = common_server_1.TelemetryStatus.DISABLED_BY_CLI_COMMAND;
        __1.CLIAnalyticsUtils.track(common_all_1.CLIEvents.CLITelemetryDisabled, { reason });
        common_server_1.SegmentClient.disable(reason);
        const message = "Telemetry is disabled.";
        this.print(message);
    }
    showMigrations() {
        // ALL_MIGRATIONS
        const headerMessage = [
            "",
            "Make note of the version number and use it in the run_migration command",
            "",
            "e.g.)",
            "> dendron dev run_migration --migrationVersion=0.64.1",
            "",
        ].join("\n");
        const body = [];
        let maxLength = 0;
        engine_server_1.ALL_MIGRATIONS.forEach((migrations) => {
            const version = migrations.version.padEnd(17);
            const changes = migrations.changes.map((set) => set.name).join(", ");
            const line = `${version}| ${changes}`;
            if (maxLength < line.length)
                maxLength = line.length;
            body.push(line);
        });
        const divider = "-".repeat(maxLength);
        this.print("======Available Migrations======");
        this.print(headerMessage);
        this.print(divider);
        this.print("version          | description");
        this.print(divider);
        this.print(body.join("\n"));
        this.print(divider);
    }
    async runMigration(opts) {
        // grab the migration we want to run
        const migrationsToRun = engine_server_1.ALL_MIGRATIONS.filter((m) => m.version === opts.migrationVersion);
        // run it
        const currentVersion = migrationsToRun[0].version;
        const wsService = new engine_server_1.WorkspaceService({ wsRoot: opts.wsRoot });
        const configPath = engine_server_1.DConfig.configPath(opts.wsRoot);
        const wsConfigPath = path_1.default.join(opts.wsRoot, common_all_1.CONSTANTS.DENDRON_WS_NAME);
        const dendronConfig = (0, common_server_1.readYAML)(configPath);
        const wsConfig = (0, common_server_1.readJSONWithCommentsSync)(wsConfigPath);
        const changes = await engine_server_1.MigrationService.applyMigrationRules({
            currentVersion,
            previousVersion: "0.0.0",
            migrations: migrationsToRun,
            wsService,
            logger: this.L,
            wsConfig,
            dendronConfig,
        });
        // report
        if (changes.length > 0) {
            changes.forEach((change) => {
                const event = lodash_1.default.isUndefined(change.error)
                    ? common_all_1.CLIEvents.CLIMigrationSucceeded
                    : common_all_1.CLIEvents.CLIMigrationFailed;
                __1.CLIAnalyticsUtils.track(event, {
                    data: change.data,
                });
                if (change.error) {
                    this.print("Migration failed.");
                    this.print(change.error.message);
                }
                else {
                    this.print("Migration succeeded.");
                }
            });
        }
    }
}
exports.DevCLICommand = DevCLICommand;
//# sourceMappingURL=devCLICommand.js.map